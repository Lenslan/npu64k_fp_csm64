// leda G_521_2_B off
// LMD: use lowercase letters
// LI: generated by APEX
`define npuarc_COREREG_SIZE 32
`include "npuarc_defines.v"
// spyglass disable_block Reset_info09b
module npuarc_uxEventManager (
// spyglass disable_block W240
        input          clk,
        input          clk_ungated,
        input  [63:0]  source1_64,
        input  [63:0]  source2_64,
        input  [3:0]   bflags_r_64,
        input  [3:0]   xflags_r_64,
        input  [5:0]   sub_opcode_64,
        input  [63:0]  source1_64_nxt,
        input  [63:0]  source2_64_nxt,
        input  [5:0]   sub_opcode_64_nxt,

        // User-defined extension register EVT_CTRL
        input  [31:0]  EVT_CTRL_ar_wdata,
        input          EVT_CTRL_ar_wen,
        output [31:0]  EVT_CTRL_ar_rdata,
        input          EVT_CTRL_ar_ren,
        input          EVT_CTRL_ar_rd_cmt,
        input          EVT_CTRL_ar_rd_abort,

        // User-defined extension register EVT_FILTER_LO
        input  [31:0]  EVT_FILTER_LO_ar_wdata,
        input          EVT_FILTER_LO_ar_wen,
        output [31:0]  EVT_FILTER_LO_ar_rdata,
        input          EVT_FILTER_LO_ar_ren,
        input          EVT_FILTER_LO_ar_rd_cmt,
        input          EVT_FILTER_LO_ar_rd_abort,

        // User-defined extension register EVT_FILTER_HI
        input  [31:0]  EVT_FILTER_HI_ar_wdata,
        input          EVT_FILTER_HI_ar_wen,
        output [31:0]  EVT_FILTER_HI_ar_rdata,
        input          EVT_FILTER_HI_ar_ren,
        input          EVT_FILTER_HI_ar_rd_cmt,
        input          EVT_FILTER_HI_ar_rd_abort,

        // User-defined extension register EVT_CNT_SEL
        input  [31:0]  EVT_CNT_SEL_ar_wdata,
        input          EVT_CNT_SEL_ar_wen,
        output [31:0]  EVT_CNT_SEL_ar_rdata,
        input          EVT_CNT_SEL_ar_ren,
        input          EVT_CNT_SEL_ar_rd_cmt,
        input          EVT_CNT_SEL_ar_rd_abort,

        // User-defined extension register EVT_CNT_VAL
        input  [31:0]  EVT_CNT_VAL_ar_wdata,
        input          EVT_CNT_VAL_ar_wen,
        output [31:0]  EVT_CNT_VAL_ar_rdata,
        input          EVT_CNT_VAL_ar_ren,
        input          EVT_CNT_VAL_ar_rd_cmt,
        input          EVT_CNT_VAL_ar_rd_abort,

        // User-defined extension register EVT_VM_SEL
        input  [31:0]  EVT_VM_SEL_ar_wdata,
        input          EVT_VM_SEL_ar_wen,
        output [31:0]  EVT_VM_SEL_ar_rdata,
        input          EVT_VM_SEL_ar_ren,
        input          EVT_VM_SEL_ar_rd_cmt,
        input          EVT_VM_SEL_ar_rd_abort,

        // User-defined extension register EVT_VM_MAP
        input  [31:0]  EVT_VM_MAP_ar_wdata,
        input          EVT_VM_MAP_ar_wen,
        output [31:0]  EVT_VM_MAP_ar_rdata,
        input          EVT_VM_MAP_ar_ren,
        input          EVT_VM_MAP_ar_rd_cmt,
        input          EVT_VM_MAP_ar_rd_abort,

        // User-defined extension register EVT_GRP_SEL
        input  [31:0]  EVT_GRP_SEL_ar_wdata,
        input          EVT_GRP_SEL_ar_wen,
        output [31:0]  EVT_GRP_SEL_ar_rdata,
        input          EVT_GRP_SEL_ar_ren,
        input          EVT_GRP_SEL_ar_rd_cmt,
        input          EVT_GRP_SEL_ar_rd_abort,

        // User-defined extension register EVT_SID
        input  [31:0]  EVT_SID_ar_wdata,
        input          EVT_SID_ar_wen,
        output [31:0]  EVT_SID_ar_rdata,
        input          EVT_SID_ar_ren,
        input          EVT_SID_ar_rd_cmt,
        input          EVT_SID_ar_rd_abort,

        // User-defined extension register EVT_SSID
        input  [31:0]  EVT_SSID_ar_wdata,
        input          EVT_SSID_ar_wen,
        output [31:0]  EVT_SSID_ar_rdata,
        input          EVT_SSID_ar_ren,
        input          EVT_SSID_ar_rd_cmt,
        input          EVT_SSID_ar_rd_abort,

        // User-defined extension register EVT_IRQ
        input  [31:0]  EVT_IRQ_ar_wdata,
        input          EVT_IRQ_ar_wen,
        output [31:0]  EVT_IRQ_ar_rdata,
        input          EVT_IRQ_ar_ren,
        input          EVT_IRQ_ar_rd_cmt,
        input          EVT_IRQ_ar_rd_abort,
        input  [95:0]  evm_event_a,
        output         evm_wakeup,
        input          evm_sleep,
        output [63:0]  evm_send,
        output [31:0]  vm_grp0_sid,
        output [31:0]  vm_grp0_ssid,
        output [31:0]  vm_grp1_sid,
        output [31:0]  vm_grp1_ssid,
        output [31:0]  vm_grp2_sid,
        output [31:0]  vm_grp3_sid,
        output [31:0]  vm_grp2_ssid,
        output [31:0]  vm_grp3_ssid,
        output         evt_vm_irq,
        output [3:0]   evt_vm_sel,
        
        input          evmww_start,
        input          evmww_stall,
        input          evmww_end,
        input          evmww_start_nxt,
        input          evmww_kill,
        input          evmww_commit,
        input          evmww_decode,
        output         evmww_busy,
        output [3:0]   evmww_bflags,
        output [3:0]   evmww_xflags,
        output [63:0]  evmww_res,
        
        input          evmw_start,
        input          evmw_stall,
        input          evmw_end,
        input          evmw_start_nxt,
        input          evmw_kill,
        input          evmw_commit,
        input          evmw_decode,
        output         evmw_busy,
        output [3:0]   evmw_bflags,
        output [3:0]   evmw_xflags,
        output [63:0]  evmw_res,
        
        input          evm_start,
        input          evm_stall,
        input          evm_end,
        input          evm_start_nxt,
        input          evm_kill,
        input          evm_commit,
        input          evm_decode,
        output         evm_busy,
        output [3:0]   evm_bflags,
        output [3:0]   evm_xflags,
        output [63:0]  evm_res,
        input          rst_a
        );



  localparam INST_MCHK      = 0;
  localparam INST_MALL      = 1;
  localparam INST_MANY      = 2;
  localparam INST_MDEC      = 3;
  localparam INST_MINC      = 4;
  localparam INST_MSND      = 5;
  localparam INST_VCHK      = 6;
  localparam VM_NUM         = 8;
  localparam VM_GRP         = 4;
  localparam EVT_NUM        = 64;
  localparam EVT_CNT_NUM    = 96;
  localparam EVT_CHILD0     = 0;
  localparam EVT_CHILD23    = 23;
  localparam EVT_STU0_ISSUE = 24;
  localparam EVT_STU0_DONE  = 25;
  localparam EVT_STU7_ISSUE = 38;
  localparam EVT_STU7_DONE  = 39;
  localparam EVT_PARENT_AC  = 40;
  localparam EVT_PHY_PEERS  = 48;
  localparam EVT_PHY_ACCL   = 64;

  reg                   event_out_r;
  reg                   event_out_nxt;

  //reg  [95:0]           evt_event_meta_r;           // metastable events
  wire [95:0]           evt_event_sync;             // events from synchronizer
  reg  [95:0]           evt_event_r;                // delayed events

  reg  [7:0]            evt_cnt_r[EVT_CNT_NUM-1:0];     // event counters
  reg  [7:0]            evt_cnt_nxt[EVT_CNT_NUM-1:0];
  reg                   evt_cnt_en[EVT_CNT_NUM-1:0];
  reg  [7:0]            evt_cnt_rd;
  reg  [7:0]            evt_cnt_nxt_inc[EVT_CNT_NUM-1:0];

  reg                   evt_ctrl_r[VM_NUM-1:0];         // 0x0f02   rw  event control 
  reg  [63:0]           evt_filter_r[VM_NUM-1:0];       // 0x0f04/5 rw  event filter
  reg  [5:0]            evt_cnt_sel_r;              // 0x0f0a   rw  event counter select
  reg  [63:0]           evt_send_r;                 // event send
  reg  [2:0]            evt_send_cnt_r;             // timer for event send 

  reg                   evt_ctrl_nxt[VM_NUM-1:0];        
  reg  [63:0]           evt_filter_nxt[VM_NUM-1:0];    
  wire [63:0]           evt_send_nxt;
  wire [2:0]            evt_send_cnt_nxt;

  reg                   evt_ctrl_en[VM_NUM-1:0];        
  reg                   evt_filter_en[VM_NUM-1:0];   
  wire                  evt_send_en;    
  wire                  evt_send_cnt_en;

  reg  [6:0]            inst_oh_r_x2_2;     // onehot0 instruction in 2nd cycle in X2 stage
  reg  [6:0]            inst_oh_r_x2_3;     // onehot0 instruction in 3rd cycle in X2 stage
  reg  [6:0]            inst_oh_r_x3;       // onehot0 instruction in X3 stage
  reg  [6:0]            inst_oh_r_ca;       // onehot0 instruction in commit stage
  reg  [6:0]            inst_oh_nxt;        // onehot0 instruction in 1st cycle in X2 stage
  reg                   inst_oh_en;

  reg                   evmww_start_x2_2;
  reg                   evmww_start_x2_3;

  reg [63:0]            op_r_x2_2;     // source operand in 2nd cycle in X2 stage
  reg [63:0]            op_r_x2_3;     // source operand in 3rd cycle in X2 stage
  reg [63:0]            op_r_x3;       // source operand in X3 stage
  reg [63:0]            op_r_ca;       // source operand in commit stage
  reg [63:0]            op_nxt;        // source operand in 1st cycle in X1 stage
  reg  [7:0]            flags_r_x2_2;
  reg  [7:0]            flags_r_x2_3;
  reg                   op_en;
  reg  [7:0]            flags_out;
  reg  [7:0]            vm_vld_x2_2;
  reg  [7:0]            vm_vld_x2_3;
  reg                   ok_x2_2;
  reg                   ok_x2_3;
  reg [63:0]            res;
  reg [63:0]            filt;
  reg [63:0]            filt_r;
  reg [95:0]            filt_mask;
  reg [95:0]            filt_mask_r;

  wire [95:0]            peers_evt_mask;
  wire [95:0]            accl_evt_mask;
  reg  [95:0]            ac_evt_mask;
  wire [EVT_CNT_NUM-1:0] phy_evt_mask_nxt;
  wire [63:0]            evt_sel;
  wire [95:0]            evt_sel_mask;
  wire [63:0]            evt_sync;
  wire [95:0]            evt_sync_mask;
  wire [95:0]            evt_filter0_mask;
  wire [95:0]            evt_filter1_mask;
  wire [95:0]            evt_filter2_mask;
  wire [95:0]            evt_filter3_mask;
  wire [95:0]            evt_filter4_mask;
  wire [95:0]            evt_filter5_mask;
  wire [95:0]            evt_filter6_mask;
  wire [95:0]            evt_filter7_mask;
  reg  [95:0]            evt_filter_mask[7:0];

  // Register MASK
  reg  [EVT_CNT_NUM-1:0] phy_evt_mask_r;
  reg  [95:0]            evt_sel_mask_r;
  reg  [95:0]            evt_filter_mask_r;

  // Generated MASK
  wire  [95:0]           op_mask_x2_2;
  wire  [95:0]           op_mask_ca;

  // Event Map Table
  reg [7:0]  evt_vm_cbase_r[VM_NUM-1:0];
  reg [7:0]  evt_vm_cnum_r[VM_NUM-1:0];
  reg [7:0]  evt_vm_abase_r[VM_NUM-1:0];
  reg [7:0]  evt_vm_anum_r[VM_NUM-1:0];

  reg [7:0]  evt_vm_map_idx_r[VM_NUM-1:0][EVT_NUM-1:0];
  reg [0:0]  evt_vm_map_ena_r[VM_NUM-1:0][EVT_NUM-1:0];

  // Event VM SEL registers
  reg [3:0]             evt_vm_sel_r;

  // Event IRQ registers
  reg                   evt_irq_r;

  // Event Group SEL registers
  reg [1:0]             evt_grp_sel_r;

  // Event SID/SSID registers
  reg [31:0]            evt_sid_r[3:0];
  reg [31:0]            evt_ssid_r[3:0];
  
  // MUX read data
  reg [31:0]            evt_sid_mux;
  reg [31:0]            evt_ssid_mux;

  // Condition Status
  reg                   cond_any_r;
  reg                   cond_any_nxt;
  reg                   cond_any_en;

  function automatic [7:0] leading_zeros;
    input [95:0] mask;
    begin : lead_zero_PROC
      reg [63:0] tap64;
      reg [31:0] tap32;
      reg [15:0] tap16;
      reg [7:0]  tap8;
      reg [3:0]  tap4;
      leading_zeros[7] = 1'b0;
      leading_zeros[6] = (mask[63:0] == 64'b0);
      tap64            = leading_zeros[6] ? {32'h0,mask[95:64]} : mask[63:0];
      leading_zeros[5] = (tap64[31:0] == 32'b0);
      tap32            = leading_zeros[5] ? tap64[63:32] : tap64[31:0];
      leading_zeros[4] = (tap32[15:0] == 16'b0);
      tap16            = leading_zeros[4] ? tap32[31:16] : tap32[15:0];
      leading_zeros[3] = (tap16[7:0] == 8'b0);
      tap8             = leading_zeros[3] ? tap16[15:8] : tap16[7:0];
      leading_zeros[2] = (tap8[3:0] == 4'b0);
      tap4             = leading_zeros[2] ? tap8[7:4] : tap8[3:0];
      leading_zeros[1] = (tap4[1:0] == 2'b0);
      leading_zeros[0] = leading_zeros[1] ? ~tap4[2] : ~tap4[0];
    end
  endfunction

  //
  // Simple assignments
  //
  //AUX read data
  assign EVT_CTRL_ar_rdata            = {31'h0,evt_ctrl_r[evt_vm_sel_r]};
  assign EVT_FILTER_LO_ar_rdata       = evt_filter_r[evt_vm_sel_r][0+:32];
  assign EVT_FILTER_HI_ar_rdata       = evt_filter_r[evt_vm_sel_r][32+:32];
  assign EVT_CNT_SEL_ar_rdata         = {26'h0,evt_cnt_sel_r};
  assign EVT_CNT_VAL_ar_rdata         = {24'h0,evt_cnt_rd};
  assign EVT_GRP_SEL_ar_rdata         = {30'h0, evt_grp_sel_r};
  assign EVT_SID_ar_rdata             = evt_sid_r[evt_grp_sel_r];
  assign EVT_SSID_ar_rdata            = evt_ssid_r[evt_grp_sel_r];
  assign EVT_VM_SEL_ar_rdata          = {28'h0, evt_vm_sel_r};
  assign EVT_VM_MAP_ar_rdata          =  32'h0;
  assign EVT_IRQ_ar_rdata             = {31'h0,evt_irq_r};

  assign evt_send_cnt_en              = (evt_send_cnt_r != 0) || (inst_oh_r_ca[INST_MSND] && evm_commit);
  assign evt_send_cnt_nxt             = (inst_oh_r_ca[INST_MSND] && evm_commit) ? 3'h5 : evt_send_cnt_r - 3'h1;
  assign evt_send_en                  = (inst_oh_r_ca[INST_MSND] && evm_commit) || (evt_send_cnt_r == 3'h1);
  assign evt_send_nxt                 = (inst_oh_r_ca[INST_MSND] && evm_commit) ? op_r_ca : 0;
  assign evm_send                     = evt_send_r;
  assign evmww_busy                   = 1'b0;
  assign evmw_busy                    = 1'b0;
  assign evm_busy                     = evt_send_cnt_r != 0;
  assign evmww_res                    = res;
  assign evmw_res                     = 0;
  assign evm_res                      = 0;
  assign {evmww_xflags,evmww_bflags}  = flags_out;
  assign {evmw_xflags,evmw_bflags}    = flags_out;
  assign {evm_xflags,evm_bflags}      = flags_out;
  assign evm_wakeup                   = event_out_r && evm_sleep;
  assign evt_vm_irq                   = evt_irq_r;
  assign evt_vm_sel                   = evt_vm_sel_r;

  //VM SID/SSID outputs
  assign vm_grp0_sid                  = evt_sid_r[0];
  assign vm_grp1_sid                  = evt_sid_r[1];
  assign vm_grp2_sid                  = evt_sid_r[2];
  assign vm_grp3_sid                  = evt_sid_r[3];
  assign vm_grp0_ssid                 = evt_ssid_r[0];
  assign vm_grp1_ssid                 = evt_ssid_r[1];
  assign vm_grp2_ssid                 = evt_ssid_r[2];
  assign vm_grp3_ssid                 = evt_ssid_r[3];

  //Event Mask
  assign peers_evt_mask               = (((96'b1<<evt_vm_cnum_r[evt_vm_sel_r])-1) << evt_vm_cbase_r[evt_vm_sel_r]) & 96'h0000_FFFF_FFFF_FFFF;
  assign accl_evt_mask                = (((96'b1<<evt_vm_anum_r[evt_vm_sel_r])-1) << evt_vm_abase_r[evt_vm_sel_r]) & 96'hFFFF_0000_0000_0000;
  always @*
  begin : ac_evt_mask_PROC
    ac_evt_mask = 96'h0;
    case (evt_vm_sel_r)
    4'h0: ac_evt_mask    = 96'h0000_000F_0000_0000_0000_0000;
    4'h1: ac_evt_mask    = 96'h0000_00F0_0000_0000_0000_0000;
    4'h2: ac_evt_mask    = 96'h0000_0F00_0000_0000_0000_0000;
    4'h3: ac_evt_mask    = 96'h0000_F000_0000_0000_0000_0000;
    4'h4: ac_evt_mask    = 96'h000F_0000_0000_0000_0000_0000;
    4'h5: ac_evt_mask    = 96'h00F0_0000_0000_0000_0000_0000;
    4'h6: ac_evt_mask    = 96'h0F00_0000_0000_0000_0000_0000;
    4'h7: ac_evt_mask    = 96'hF000_0000_0000_0000_0000_0000;
    default: ac_evt_mask = 96'h0;
    endcase
  end
  assign phy_evt_mask_nxt             = peers_evt_mask | accl_evt_mask | ac_evt_mask;
  assign op_mask_x2_2                 = (({32'h0,16'h0,24'h0,op_r_x2_2[23:0]} << evt_vm_cbase_r[evt_vm_sel_r]) & 96'h0000_FFFF_FFFF_FFFF)
                                      | (({32'h0,48'h0,op_r_x2_2[39:24]} << evt_vm_abase_r[evt_vm_sel_r]) & 96'hFFFF_0000_0000_0000)
                                      | (({op_r_x2_2[63:40],16'h0,48'h0} << {evt_vm_sel_r,2'b0}));
  assign op_mask_ca                   = (({32'h0,16'h0,24'h0,op_r_ca[23:0]} << evt_vm_cbase_r[evt_vm_sel_r]) & 96'h0000_FFFF_FFFF_FFFF)
                                      | (({32'h0,48'h0,op_r_ca[39:24]} << evt_vm_abase_r[evt_vm_sel_r]) & 96'hFFFF_0000_0000_0000)
                                      | (({op_r_ca[63:40],16'h0,48'h0} << {evt_vm_sel_r,2'b0}));
  assign evt_sel                      = (64'h1 << evt_cnt_sel_r);
  assign evt_sel_mask                 = (({32'h0,16'h0,24'h0,evt_sel[23:0]} << evt_vm_cbase_r[evt_vm_sel_r]) & 96'h0000_FFFF_FFFF_FFFF)
                                      | (({32'h0,48'h0,evt_sel[39:24]} << evt_vm_abase_r[evt_vm_sel_r]) & 96'hFFFF_0000_0000_0000)
                                      | (({evt_sel[63:40],16'h0,48'h0} << {evt_vm_sel_r,2'b0}));

  assign evt_sync_mask                = evt_event_sync & (~evt_event_r);

  assign evt_filter0_mask             = (({32'h0,16'h0,24'h0,evt_filter_r[0][23:0]} << evt_vm_cbase_r[0]) & 96'h0000_FFFF_FFFF_FFFF)
                                      | (({32'h0,48'h0,evt_filter_r[0][39:24]} << evt_vm_abase_r[0]) & 96'hFFFF_0000_0000_0000)
                                      | (({evt_filter_r[0][63:40],16'h0,48'h0}));
  assign evt_filter1_mask             = (({32'h0,16'h0,24'h0,evt_filter_r[1][23:0]} << evt_vm_cbase_r[1]) & 96'h0000_FFFF_FFFF_FFFF)
                                      | (({32'h0,48'h0,evt_filter_r[1][39:24]} << evt_vm_abase_r[1]) & 96'hFFFF_0000_0000_0000)
                                      | (({evt_filter_r[1][63:40],16'h0,48'h0} << 4));
  assign evt_filter2_mask             = (({32'h0,16'h0,24'h0,evt_filter_r[2][23:0]} << evt_vm_cbase_r[2]) & 96'h0000_FFFF_FFFF_FFFF)
                                      | (({32'h0,48'h0,evt_filter_r[2][39:24]} << evt_vm_abase_r[2]) & 96'hFFFF_0000_0000_0000)
                                      | (({evt_filter_r[2][63:40],16'h0,48'h0} << 8));
  assign evt_filter3_mask             = (({32'h0,16'h0,24'h0,evt_filter_r[3][23:0]} << evt_vm_cbase_r[3]) & 96'h0000_FFFF_FFFF_FFFF)
                                      | (({32'h0,48'h0,evt_filter_r[3][39:24]} << evt_vm_abase_r[3]) & 96'hFFFF_0000_0000_0000)
                                      | (({evt_filter_r[3][63:40],16'h0,48'h0} << 12));
  assign evt_filter4_mask             = (({32'h0,16'h0,24'h0,evt_filter_r[4][23:0]} << evt_vm_cbase_r[4]) & 96'h0000_FFFF_FFFF_FFFF)
                                      | (({32'h0,48'h0,evt_filter_r[4][39:24]} << evt_vm_abase_r[4]) & 96'hFFFF_0000_0000_0000)
                                      | (({evt_filter_r[4][63:40],16'h0,48'h0} << 16));
  assign evt_filter5_mask             = (({32'h0,16'h0,24'h0,evt_filter_r[5][23:0]} << evt_vm_cbase_r[5]) & 96'h0000_FFFF_FFFF_FFFF)
                                      | (({32'h0,48'h0,evt_filter_r[5][39:24]} << evt_vm_abase_r[5]) & 96'hFFFF_0000_0000_0000)
                                      | (({evt_filter_r[5][63:40],16'h0,48'h0} << 20));
  assign evt_filter6_mask             = (({32'h0,16'h0,24'h0,evt_filter_r[6][23:0]} << evt_vm_cbase_r[6]) & 96'h0000_FFFF_FFFF_FFFF)
                                      | (({32'h0,48'h0,evt_filter_r[6][39:24]} << evt_vm_abase_r[6]) & 96'hFFFF_0000_0000_0000)
                                      | (({evt_filter_r[6][63:40],16'h0,48'h0} << 24));
  assign evt_filter7_mask             = (({32'h0,16'h0,24'h0,evt_filter_r[7][23:0]} << evt_vm_cbase_r[7]) & 96'h0000_FFFF_FFFF_FFFF)
                                      | (({32'h0,48'h0,evt_filter_r[7][39:24]} << evt_vm_abase_r[7]) & 96'hFFFF_0000_0000_0000)
                                      | (({evt_filter_r[7][63:40],16'h0,48'h0} << 28));
  always @*
  begin
    evt_filter_mask[0] = evt_filter0_mask;
    evt_filter_mask[1] = evt_filter1_mask;
    evt_filter_mask[2] = evt_filter2_mask;
    evt_filter_mask[3] = evt_filter3_mask;
    evt_filter_mask[4] = evt_filter4_mask;
    evt_filter_mask[5] = evt_filter5_mask;
    evt_filter_mask[6] = evt_filter6_mask;
    evt_filter_mask[7] = evt_filter7_mask;
  end

  // Update VM mask register
  always @(posedge clk_ungated or
           posedge rst_a)
  begin : upd_phy_mask_PROC
    if (rst_a == 1'b1)
    begin
      phy_evt_mask_r       <=  0;
      evt_sel_mask_r       <=  0;
      evt_filter_mask_r    <=  0;
    end
    else
    begin
      phy_evt_mask_r       <=  phy_evt_mask_nxt;
      evt_sel_mask_r       <=  evt_sel_mask;
      case (evt_vm_sel_r)
      4'h0: evt_filter_mask_r <= evt_filter0_mask;
      4'h1: evt_filter_mask_r <= evt_filter1_mask;
      4'h2: evt_filter_mask_r <= evt_filter2_mask;
      4'h3: evt_filter_mask_r <= evt_filter3_mask;
      4'h4: evt_filter_mask_r <= evt_filter4_mask;
      4'h5: evt_filter_mask_r <= evt_filter5_mask;
      4'h6: evt_filter_mask_r <= evt_filter6_mask;
      4'h7: evt_filter_mask_r <= evt_filter7_mask;
      default: evt_filter_mask_r <= 96'h0;
      endcase
    end
  end

  // Update GRP SEL/SID/SSID register
  always @(posedge clk_ungated or
           posedge rst_a)
  begin : upd_grpsl_sid_PROC
    integer i,j;
    if (rst_a == 1'b1)
    begin
      evt_grp_sel_r      <=  0;
      for (i = 0; i < VM_GRP; i = i + 1)
      begin
        evt_sid_r[i]     <=  0;
        evt_ssid_r[i]    <=  0;
      end
    end
    else
    begin
      if (EVT_GRP_SEL_ar_wen) begin
        evt_grp_sel_r     <= EVT_GRP_SEL_ar_wdata[1:0];
      end
      if (EVT_SID_ar_wen) begin
        for (i = 0; i < VM_GRP; i = i + 1)
        begin
          if (evt_grp_sel_r == $unsigned(i))
          begin
            evt_sid_r[i]  <= EVT_SID_ar_wdata;
          end
        end
      end
      if (EVT_SSID_ar_wen) begin
        for (i = 0; i < VM_GRP; i = i + 1)
        begin
          if (evt_grp_sel_r == $unsigned(i))
          begin
            evt_ssid_r[i] <= EVT_SSID_ar_wdata;
          end
        end
      end
    end
  end

  //Update MAP Table
  always @(posedge clk_ungated or
           posedge rst_a)
  begin : upd_vm_evt_map_PROC
    integer i,j;
    if (rst_a == 1'b1)
    begin
      evt_vm_sel_r       <=  0;
      evt_irq_r          <=  0;
      for (i = 0; i < VM_NUM; i = i + 1)
      begin
        evt_vm_cbase_r[i]          <= 0;
        evt_vm_cnum_r[i]           <= 8'h18;
        evt_vm_abase_r[i]          <= 8'h30;
        evt_vm_anum_r[i]           <= 8'h10;
      end
    end
    else
    begin
      if (EVT_VM_SEL_ar_wen) begin
        evt_vm_sel_r     <= EVT_VM_SEL_ar_wdata[3:0];
      end
      if (EVT_IRQ_ar_wen) begin
        evt_irq_r        <= EVT_IRQ_ar_wdata[0];
      end
      if (EVT_VM_MAP_ar_wen) begin
        evt_vm_cbase_r[evt_vm_sel_r]          <= EVT_VM_MAP_ar_wdata[ 7: 0];
        evt_vm_cnum_r[evt_vm_sel_r]           <= EVT_VM_MAP_ar_wdata[15: 8];
        evt_vm_abase_r[evt_vm_sel_r]          <= EVT_VM_MAP_ar_wdata[23:16];
        evt_vm_anum_r[evt_vm_sel_r]           <= EVT_VM_MAP_ar_wdata[31:24];
      end
    end
  end

  //
  // Read event counter
  //
  always @*
  begin : cnt_rd_PROC
    integer i;
    evt_cnt_rd      = 0;
    for (i = 0; i < EVT_CNT_NUM; i = i + 1)
    begin
      if ((evt_sel_mask_r[i]) && (phy_evt_mask_r[i]))
      begin
        evt_cnt_rd   = evt_cnt_r[i];
      end
    end
  end

  //
  // Write event counters
  //
  always @*
  begin : cnt_wr_PROC
    integer i;
    // default outputs
    for (i = 0; i < EVT_CNT_NUM; i = i + 1)
    begin
      evt_cnt_nxt[i]                 = evt_cnt_r[i];
      evt_cnt_en[i]                  = 0;
    end
    for (i = 0; i < EVT_CNT_NUM; i = i + 1)
    begin
      //Counter Saturate
      casez ({evmw_commit, inst_oh_r_ca[INST_MDEC], op_mask_ca[i], evt_sync_mask[i]})
      4'b0??1:  evt_cnt_nxt_inc[i] = (evt_cnt_r[i] == 8'hFF) ? 8'd0 : 8'd1;                                    //Only EVT input
      4'b1?01:  evt_cnt_nxt_inc[i] = (evt_cnt_r[i] == 8'hFF) ? 8'd0 : 8'd1;                                    //Only EVT Input
      4'b1011:  evt_cnt_nxt_inc[i] = (evt_cnt_r[i] == 8'hFF) ? 8'd0 : ((evt_cnt_r[i] == 8'hFE) ? 8'd1 : 8'd2); //EVT INCR + EVT Input
      4'b1111:  evt_cnt_nxt_inc[i] = 8'd0;                                                                     //EVT DECR + EVT Input
      4'b1010:  evt_cnt_nxt_inc[i] = (evt_cnt_r[i] == 8'hFF) ? 8'd0 : 8'd1;                                    //Only EVT INCR
      4'b1110:  evt_cnt_nxt_inc[i] = (evt_cnt_r[i] == 8'h0)  ? 8'd0 : 8'hff;                                   //Only EVT DECR
      default:  evt_cnt_nxt_inc[i] = 0;     // NO HIT
      endcase
      evt_cnt_nxt[i]              = evt_cnt_r[i] + evt_cnt_nxt_inc[i];
      evt_cnt_en[i]               = (evmw_commit || evt_sync_mask[i]);
    end
    // AUX write
    if (EVT_CNT_VAL_ar_wen)
    begin
      for (i = 0; i < EVT_CNT_NUM; i = i + 1)
      begin
        if ((evt_sel_mask_r[i]) && (phy_evt_mask_r[i]))
        begin
          evt_cnt_nxt[i]    = EVT_CNT_VAL_ar_wdata;
          evt_cnt_en[i]     = 1'b1;
        end
      end
    end
  end // block: cnt_wr_PROC
  

  //
  // Instuction decoder
  //
  always @*
  begin : dec_PROC
    // defaults
    inst_oh_nxt                          = 0;
    inst_oh_en                           = 1'b0;
    op_en                                = 1'b0;
    op_nxt                               = source2_64;
    if ((inst_oh_r_ca != 0) && (evmww_commit || evmw_commit || evm_commit))
    begin
      // commit instuction
      inst_oh_en                         = 1'b1;
    end
    if (evmww_start)
    begin
      inst_oh_en                         = 1'b1;
      op_en                              = 1'b1;

      if (0==(|sub_opcode_64[5:1])) //INST_MCHK:0 INST_MALL:1
        begin
          if (sub_opcode_64[0]) inst_oh_nxt[INST_MALL]  = 1'b1;
          else                  inst_oh_nxt[INST_MCHK]  = 1'b1;
        end
      else
        begin
          if (sub_opcode_64[2]) inst_oh_nxt[INST_VCHK]  = 1'b1;
          else                  inst_oh_nxt[INST_MANY]  = 1'b1;
        end
    end
    if (evmw_start)
    begin
      inst_oh_en                         = 1'b1;
      op_en                              = 1'b1;

      //INST_MDEC: 3
      if ((0==(|sub_opcode_64[5:3])) && (sub_opcode_64[2:0]==3'b011))
        begin
          inst_oh_nxt[INST_MDEC]  = 1'b1;
        end
      else
        begin
          inst_oh_nxt[INST_MINC]  = 1'b1;
        end
    end
    if (evm_start)
    begin
      inst_oh_en                         = 1'b1;
      op_en                              = 1'b1;
      inst_oh_nxt[INST_MSND]             = 1'b1; //SND
    end
  end



  //
  // Next filter value
  //
  always @*
  begin :  filter_nxt_PROC
    integer i;
    for (i = 0; i < VM_NUM; i = i + 1)
    begin
      evt_ctrl_en[i]                   = 1'b0;
      evt_filter_en[i]                 = 1'b0;
      evt_ctrl_nxt[i]                  = 0;
      evt_filter_nxt[i]                = evt_filter_r[i];
    end
    if (inst_oh_r_ca[INST_MALL] && evmww_commit)
    begin
      // all instruction
      evt_ctrl_en[evt_vm_sel_r]        = 1'b1;
      evt_filter_en[evt_vm_sel_r]      = 1'b1;
      evt_ctrl_nxt[evt_vm_sel_r]       = 1'b0;
      evt_filter_nxt[evt_vm_sel_r]     = op_r_ca;
    end
    if (inst_oh_r_ca[INST_MANY] && evmww_commit)
    begin
      // any instruction
      evt_ctrl_en[evt_vm_sel_r]        = 1'b1;
      evt_filter_en[evt_vm_sel_r]      = 1'b1;
      evt_ctrl_nxt[evt_vm_sel_r]       = 1'b1;
      evt_filter_nxt[evt_vm_sel_r]     = op_r_ca;
    end
    if (inst_oh_r_ca[INST_MCHK] && evmww_commit)
    begin
      // Check Flags instruction
      evt_filter_en[evt_vm_sel_r]      = 1'b1;
      evt_filter_nxt[evt_vm_sel_r]     = op_r_ca;
    end
    if (EVT_CTRL_ar_wen)
    begin
      // AUX write control
      evt_ctrl_en[evt_vm_sel_r]        = 1'b1;
      evt_ctrl_nxt[evt_vm_sel_r]       = EVT_CTRL_ar_wdata[0];
    end
    if (EVT_FILTER_LO_ar_wen)
    begin
      // AUX write low filter
      evt_filter_en[evt_vm_sel_r]          = 1'b1;
      evt_filter_nxt[evt_vm_sel_r][0+:32]  = EVT_FILTER_LO_ar_wdata;
    end
    if (EVT_FILTER_HI_ar_wen)
    begin
      // AUX write high filter
      evt_filter_en[evt_vm_sel_r]          = 1'b1;
      evt_filter_nxt[evt_vm_sel_r][32+:32] = EVT_FILTER_HI_ar_wdata;
    end
  end

  
  //
  // Event filtering
  //
  always @*
  begin : filter_PROC
    integer i, j, l;
    reg           wakeup;
    reg [7:0]     cvt_cntr;
    reg [2:0]     vchk_idx;
    reg           flg;
    reg [EVT_CNT_NUM-1:0]    cnt_mask;
    reg [EVT_CNT_NUM-1:0]    cnt_nz;
    reg                      cond_any;
    cvt_cntr    = 8'b0;
    vchk_idx    = 3'b0;
    flg         = 1'b0;
    cnt_mask    = 0;
    cnt_nz      = 0;
    cond_any    = 1'b0;
    filt        = filt_r;
    filt_mask   = filt_mask_r;
    vm_vld_x2_2 = 0;
    ok_x2_2     = 0;
    res         = 0;
    wakeup      = 0;
    for (i = 0; i < EVT_CNT_NUM; i = i + 1)
    begin
      if (evt_cnt_r[i] != 0)
      begin
        cnt_nz[i]= 1'b1;
      end
    end
    if (evmww_start_x2_2)
    begin
      if (inst_oh_r_x2_2[INST_MANY] || inst_oh_r_x2_2[INST_MALL]) // MASKANY/MASKALL
      begin
        filt         = op_r_x2_2;
        filt_mask    = op_mask_x2_2;
        cond_any     = inst_oh_r_x2_2[INST_MANY];
      end
      if (inst_oh_r_x2_2[INST_MCHK])
      begin
        filt         = evt_filter_r[evt_vm_sel_r];
        filt_mask    = evt_filter_mask_r;
        cond_any     = evt_ctrl_r[evt_vm_sel_r];
      end
      if (inst_oh_r_x2_2[INST_VCHK])
      begin
        // check next VM can wakeup 
        for (l = 0; l < VM_NUM; l = l + 1)
        begin
          if (evt_ctrl_r[l] == 1'b1) // any mode
          begin
            vm_vld_x2_2[l]= |(evt_filter_mask[l] & cnt_nz);
          end
          else // all mode
          begin
            vm_vld_x2_2[l] = (((evt_filter_mask[l] & cnt_nz) == evt_filter_mask[l]) && (|(evt_filter_mask[l] & cnt_nz)));
          end
        end
        ok_x2_2 = |vm_vld_x2_2;
      end
    end
    if (evmww_start_x2_3)
    begin
    // X2_3 stage to calculate res for VCHK && COND Any
      if (inst_oh_r_x2_3[INST_VCHK])
      begin
        for (l = 1; l <= VM_NUM; l = l + 1)
        begin
          vchk_idx = (l+evt_vm_sel_r);
          if (~flg)
          begin
            flg  = (vm_vld_x2_3[vchk_idx] == 1'b1);
            res  = {61'b0,vchk_idx};
          end
        end
      end
      if ((inst_oh_r_x2_3[INST_MANY]) || ((inst_oh_r_x2_3[INST_MCHK]) && evt_ctrl_r[evt_vm_sel_r])) // cond any
      begin
        cnt_mask      = (96'b1 << vm_vld_x2_3);
        res           = ({cnt_mask[95:64] >> {evt_vm_sel_r,2'b0},  40'b0}         & 64'hFFFF_FF00_0000_0000)
                      | ({cnt_mask[63: 0] >> evt_vm_abase_r[evt_vm_sel_r], 24'h0} & 64'h0000_00FF_FF00_0000)
                      | ({cnt_mask[47: 0] >> evt_vm_cbase_r[evt_vm_sel_r]}        & 64'h0000_0000_00FF_FFFF);
      end
      if ((inst_oh_r_x2_2[INST_MALL]) || ((inst_oh_r_x2_3[INST_MCHK]) && (~evt_ctrl_r[evt_vm_sel_r]))) // cond all
      begin
        res           = filt_r;
      end
    end
    // Check for Event Flags
    if (inst_oh_r_x2_2[INST_MANY] || inst_oh_r_x2_2[INST_MALL] || inst_oh_r_x2_2[INST_MCHK])
    begin
      // MASKANY/MASKALL/MASKCHK instructions
      if (cond_any)
      begin
        vm_vld_x2_2   = leading_zeros(filt_mask & cnt_nz);
        ok_x2_2       = (|(filt_mask & cnt_nz));
      end
      else
      begin
        // check if all bits from filter are set
        ok_x2_2       = ((filt_mask & cnt_nz) == filt_mask);
      end
    end
    else
    begin
      // check for wevt to wakeup
      if (evt_ctrl_r[evt_vm_sel_r])
      begin
        wakeup        = (|(filt_mask & cnt_nz));
      end
      else
      begin
        // check if all bits from filter are set
        wakeup        = ((filt_mask & cnt_nz) == filt_mask);
      end
    end

    // output flags
    flags_out      = flags_r_x2_3;
    flags_out[3]   = ok_x2_3;
    // output event
    event_out_nxt  = wakeup && evm_sleep;
  end // block: filter_PROC


  //
  // Registers
  //
  always @(posedge clk_ungated or
           posedge rst_a)
  begin : reg_PROC
    integer i,j;
    if (rst_a == 1'b1)
    begin
      evmww_start_x2_2      <= 0;
      evmww_start_x2_3      <= 0;
      ok_x2_3               <= 0;
      vm_vld_x2_3           <= 0;
      event_out_r           <= 0;
      //evt_event_meta_r      <= 0;
      //evt_event_sync_r      <= 0;
      evt_event_r           <= 0;
      for (i = 0; i < EVT_CNT_NUM; i = i + 1)
      begin
        evt_cnt_r[i]        <= 0;
      end
      for (i = 0; i < VM_NUM; i = i + 1)
      begin
        evt_ctrl_r[i]       <= 0;
        evt_filter_r[i]     <= 0;
      end
      evt_cnt_sel_r         <= 0;
      evt_send_r            <= 0;
      evt_send_cnt_r        <= 0;
      inst_oh_r_x2_2        <= 0;
      inst_oh_r_x2_3        <= 0;
      inst_oh_r_x3          <= 0;
      inst_oh_r_ca          <= 0;
      op_r_x2_2             <= 0;
      op_r_x2_3             <= 0;
      op_r_x3               <= 0;
      op_r_ca               <= 0;
      flags_r_x2_2          <= 0;
      flags_r_x2_3          <= 0;
      filt_r                <= 0;
      filt_mask_r           <= 0;
    end
    else 
    begin
      if (inst_oh_en)
      begin
        inst_oh_r_x2_2        <= inst_oh_nxt;
      end
      if (op_en)
      begin
        op_r_x2_2             <= op_nxt;
        flags_r_x2_2          <= {xflags_r_64,bflags_r_64};
      end
      if (~evmww_stall) begin
        evmww_start_x2_2      <= evmww_start;
        evmww_start_x2_3      <= evmww_start_x2_2;
      end
      if ((~evmw_stall) && (~evm_stall) && (~evmww_stall)) begin
        ok_x2_3               <= ok_x2_2;
        vm_vld_x2_3           <= vm_vld_x2_2;
        inst_oh_r_x2_3        <= inst_oh_r_x2_2;
        inst_oh_r_x3          <= inst_oh_r_x2_3;
        inst_oh_r_ca          <= inst_oh_r_x3;
        op_r_x2_3             <= op_r_x2_2;
        op_r_x3               <= op_r_x2_3;
        op_r_ca               <= op_r_x3;
        flags_r_x2_3          <= flags_r_x2_2;
      end
      event_out_r           <= event_out_nxt;
      //evt_event_meta_r      <= evm_event_a;
      //evt_event_sync_r      <= evt_event_meta_r;
      evt_event_r           <= evt_event_sync;
      filt_r                <= filt;
      filt_mask_r           <= filt_mask;
      for (i = 0; i < EVT_CNT_NUM; i = i + 1)
      begin
        if (evt_cnt_en[i])
        begin
          evt_cnt_r[i] <= evt_cnt_nxt[i];
        end
      end
      for (j = 0; j < VM_NUM; j = j + 1)
      begin
        if (evt_ctrl_en[j])
        begin
          evt_ctrl_r[j]          <= evt_ctrl_nxt[j];
        end
        if (evt_filter_en[j])
        begin
          evt_filter_r[j]        <= evt_filter_nxt[j];
        end
      end
      if (EVT_CNT_SEL_ar_wen)
      begin
        evt_cnt_sel_r       <= EVT_CNT_SEL_ar_wdata[5:0];
      end
      if (evt_send_en)
      begin
        evt_send_r          <= evt_send_nxt;
      end
      if (evt_send_cnt_en)
      begin
        evt_send_cnt_r      <= evt_send_cnt_nxt;
      end
    end
  end

  genvar i;
  generate
    for (i = 0; i < 96; i=i+1)
    begin
      npuarc_cdc_sync 
      u_evt_sync
      (
          .clk(clk_ungated)
        , .rst_a(rst_a)
        , .din(evm_event_a[i])
        , .dout(evt_event_sync[i])
      );
    end
  endgenerate

// spyglass enable_block W240
// leda G_521_2_B on
endmodule
// spyglass enable_block Reset_info09b
