/*
 * Copyright (C) 2021-2023 Synopsys, Inc. All rights reserved.
 *
 * SYNOPSYS CONFIDENTIAL - This is an unpublished, confidential, and
 * proprietary work of Synopsys, Inc., and may be subject to patent,
 * copyright, trade secret, and other legal or contractual protection.
 * This work may be used only pursuant to the terms and conditions of a
 * written license agreement with Synopsys, Inc. All other use, reproduction,
 * distribution, or disclosure of this work is strictly prohibited.
 *
 * The entire notice above must be reproduced on all authorized copies.
 */

//
// Top-level demo file for the VM BUS 
//
 
`include "npu_defines.v"
`include "npu_vm_macros.svh"
`include "npu_vm_ecc_macros.sv"

`ifndef NPU_ECC_TYPES_IMPORTED
`define NPU_ECC_TYPES_IMPORTED
import npu_ecc_types::*;
`endif
// spyglass disable_block W240
// SMD: Declared but not read
// SJ: Reviewed
module vm_mux_logic_data_addr
  import npu_types::*;
#(
    parameter VM_RPORTS=(((NUM_FM_QUEUE+NUM_COEF_QUEUE+CONV_PAD_LD_LANES+VSIZE+GTOA_BPAR_LD_LANES+GTOA_MPST_LANES+DMA_VM_LANES)+1)+1),
    parameter VM_WPORTS=((VSIZE+GTOA_MPST_LANES+DMA_VM_LANES)+1),
    parameter NUM_VM_BANKS=((VSIZE==8)?32:16),
    parameter int WWID = 16-$clog2(NUM_VM_BANKS)+ISIZE*9
   )
  (

   input  logic     [VM_WPORTS-1:0]     nn_vm_wr_cmd_valid,  // write command valid
   input  vm_addr_t [VM_WPORTS-1:0]     nn_vm_wr_cmd_addr,   // write command address
   input  ixpix_t   [VM_WPORTS-1:0]     nn_vm_wr_wdata,      // write data

   // read request
   input  logic     [VM_RPORTS-1:0]     nn_vm_rd_cmd_valid,  // read command valid
   input  vm_addr_t [VM_RPORTS-1:0]     nn_vm_rd_cmd_addr,   // read command address
   output ixpix_t   [VM_RPORTS-1:0]     nn_vm_rd_rdata,      // read data   
   // muxed request
   output vm_addr_t [NUM_VM_BANKS-1:0]  vm_addr,    // command address
   output ixpix_t   [NUM_VM_BANKS-1:0]  vm_wdata,   // write data
   input  ixpix_t   [NUM_VM_BANKS-1:0]  vm_rdata,   // read data

   input  logic     [NUM_VM_BANKS-1:0]  vm_mem_en_r,
   input  logic     [NUM_VM_BANKS-1:0]  vm_ls_r,
   input  logic     [NUM_VM_BANKS-1:0]  vm_ldst_en_r,
   input  ixbit_t   [NUM_VM_BANKS-1:0]  nn_vm_wr_wstrb_r,

   output logic     [NUM_VM_BANKS-1:0]  vm_mem_en,  // load enable
   output logic     [NUM_VM_BANKS-1:0]  vm_ls,      // light sleep
   output logic     [NUM_VM_BANKS-1:0]  vm_ds,      // deep sleep
   output logic     [NUM_VM_BANKS-1:0]  vm_ldst_en, // store enable
   output ixbit_t   [NUM_VM_BANKS-1:0]  vm_wstrb,   // write strobe

   //
   // vm ecc
   //
   input  logic                      vm_prot_en,

   // vm mem access interface
   output vm_ecc_c_t [NUM_VM_BANKS-1:0]                  vm_wecc,  // write ecc
   output            [NUM_VM_BANKS-1:0] [VM_NUM_ECC-1:0] vm_ecc_wstrb,

   // vm port access interface

// input signals
   input  vm_addr_t   [NUM_VM_BANKS-1:0]                     vm_addr_r,
   input  ixpix_t     [NUM_VM_BANKS-1:0]                     nn_vm_wr_wdata_r,
   input  ixpix_t     [NUM_VM_BANKS-1:0]                     nn_vm_rd_rdata_r,
   input  vm_ecc_c_t  [NUM_VM_BANKS-1:0]                     nn_vm_wr_ecc_r,
   input  logic       [NUM_VM_BANKS-1:0] [VM_NUM_ECC-1:0]    nn_vm_wr_ecc_wstrb_r,
   input  vm_ecc_c_t  [NUM_VM_BANKS-1:0]                     nn_vm_rd_ecc_r,
   input  logic       [VM_RPORTS-1:0][2:0][NUM_VM_BANKS-1:0] bank_r,
   input  logic       [NUM_VM_BANKS-1:0]                     wfifo_rvalid,
   input  logic       [NUM_VM_BANKS-1:0][WWID-1:0]           wfifo_rdata,
   input  logic       [NUM_VM_BANKS-1:0]                     wfifo_prio, 

// output signals 
   output vm_addr_t   [NUM_VM_BANKS-1:0]                     vm_addr_nxt,        
   output ixpix_t     [NUM_VM_BANKS-1:0]                     nn_vm_wr_wdata_nxt, 

  // mem ecc
   output vm_ecc_c_t  [NUM_VM_BANKS-1:0]                     nn_vm_wr_ecc_nxt,   // ecc generated by ecc encoder
   output logic                                              sb_err_aggr,
   output logic                                              db_err_aggr,
   // vm initialization
   input logic      vm_init,
   input vm_addr_t  vm_init_wr_cmd_addr, // vm init write command address
   //
   // clock and rst_a
   //
   input logic      clk,                   // clock, all logic clocked at posedge
   input logic      rst_a                  // asynchronous rst_a, active high


  );
// spyglass enable_block W240

  localparam VM_PORTS_WIDTH=$clog2(NUM_VM_BANKS);

  // mem ecc
  logic mem_ecc_en;
  assign mem_ecc_en = vm_prot_en;
  logic       [NUM_VM_BANKS-1:0] [VM_NUM_ECC-1:0] gen_sb_err;         // sbe generated by ecc decoder
  logic       [NUM_VM_BANKS-1:0] [VM_NUM_ECC-1:0] gen_db_err;         // dbe generated by ecc decoder
  ixpix_t     [NUM_VM_BANKS-1:0]                  int_vm_rd_c_rdata;
  logic       [NUM_VM_BANKS-1:0]                  rd_ecc_sel;

 // arbitration per bank
  always_comb
  begin : vm_bus_ack_PROC
    logic f;
    vm_addr_nxt         = '0;
    nn_vm_wr_wdata_nxt  = '0;
    // shift bank next

// spyglass disable_block W362
// SMD: an arithmetic comparison operator with unequal length
// SJ: it's compare to the int type, no side effects
    for (int i=0; i<NUM_VM_BANKS; i++) 
    begin //{
      if (vm_init) begin
          vm_addr_nxt[i]         |= {{VM_PORTS_WIDTH{1'b0}},vm_init_wr_cmd_addr[15:VM_PORTS_WIDTH]};
          nn_vm_wr_wdata_nxt[i]  |= '0;
      end
      else begin
      f = wfifo_prio[i];
      // conv and gtoa read have highest priority
      //for (int n=0; n<4*VSIZE+CONV_PAD_LD_LANES+GTOA_MPST_LANES+GTOA_BPAR_LD_LANES; n++) begin //{
      for (int n=0; n<NUM_FM_QUEUE+NUM_COEF_QUEUE+CONV_PAD_LD_LANES+VSIZE+GTOA_BPAR_LD_LANES+GTOA_MPST_LANES; n++) begin //{
        if ((nn_vm_rd_cmd_addr[n][VM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_vm_rd_cmd_valid[n]) 
        begin    //select read operation
          vm_addr_nxt[i]         |= f ? '0 : {{VM_PORTS_WIDTH{1'b0}},nn_vm_rd_cmd_addr[n][15:VM_PORTS_WIDTH]};
          f                      |= 1'b1;
        end
      end //}
      // pool write ports
      for (int n=VSIZE; n<VSIZE+GTOA_MPST_LANES; n++) 
      begin //{
        if ((nn_vm_wr_cmd_addr[n][VM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_vm_wr_cmd_valid[n]) 
        begin    //select read operation
          vm_addr_nxt[i]         |= f ? '0 : {{VM_PORTS_WIDTH{1'b0}},nn_vm_wr_cmd_addr[n][15:VM_PORTS_WIDTH]};
          nn_vm_wr_wdata_nxt[i]  |= f ? '0 : nn_vm_wr_wdata[n];
          f                      |= 1'b1;
        end
      end //}
      // write ports have second highest priority and highest if priority inverted
      f &= ~wfifo_prio[i];
      if (wfifo_rvalid[i]) 
      begin // select write operation
        vm_addr_nxt[i]         |= f ? '0 : {{VM_PORTS_WIDTH{1'b0}},wfifo_rdata[i][9*ISIZE+:16-VM_PORTS_WIDTH]};
        nn_vm_wr_wdata_nxt[i]  |= f ? '0 : wfifo_rdata[i][ISIZE+:8*ISIZE];
        f                      |= 1'b1;
      end //}

      // rest
      //for (int n=4*VSIZE+CONV_PAD_LD_LANES+GTOA_MPST_LANES+GTOA_BPAR_LD_LANES; n<VM_RPORTS; n++) begin //{
      for (int n=NUM_FM_QUEUE+NUM_COEF_QUEUE+CONV_PAD_LD_LANES+VSIZE+GTOA_BPAR_LD_LANES+GTOA_MPST_LANES; n<VM_RPORTS; n++) begin //{
        if ((nn_vm_rd_cmd_addr[n][VM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_vm_rd_cmd_valid[n])
        begin    //select read operation
          vm_addr_nxt[i]         |= f ? '0 : {{VM_PORTS_WIDTH{1'b0}},nn_vm_rd_cmd_addr[n][15:VM_PORTS_WIDTH]};
          f                      |= 1'b1;
        end
      end //}

      end
    end //}
// spyglass enable_block W362
  end : vm_bus_ack_PROC


   `include "vm_ecc_2nd_func.sv"
  localparam CFG_NPU_MEM_ECC = 1;
  always_comb
  begin : vm_ecc_PROC
    logic f;

// spyglass disable_block W362
// SMD: an arithmetic comparison operator with unequal length
// SJ: it's compare to the int type, no side effects
    for (int i=0; i<NUM_VM_BANKS; i++) 
    begin //{
      if (vm_init) begin
      end
      else begin
      f = wfifo_prio[i];
      // conv and gtoa read have highest priority
      for (int n=0; n<NUM_FM_QUEUE+NUM_COEF_QUEUE+CONV_PAD_LD_LANES+VSIZE+GTOA_BPAR_LD_LANES+GTOA_MPST_LANES; n++) begin //{
        if ((nn_vm_rd_cmd_addr[n][VM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_vm_rd_cmd_valid[n]) 
        begin    //select read operation
          f                      |= 1'b1;
        end
      end //}

      // pool write ports
      for (int n=VSIZE; n<VSIZE+GTOA_MPST_LANES; n++) 
      begin //{
        if ((nn_vm_wr_cmd_addr[n][VM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_vm_wr_cmd_valid[n]) 
        begin    //select read operation
          f                      |= 1'b1;
        end
      end //}
      // write ports have second highest priority and highest if priority inverted
      f &= ~wfifo_prio[i];
      if (wfifo_rvalid[i]) 
      begin // select write operation
          f                      |= 1'b1;
      end //}

      // rest
      for (int n=NUM_FM_QUEUE+NUM_COEF_QUEUE+CONV_PAD_LD_LANES+VSIZE+GTOA_BPAR_LD_LANES+GTOA_MPST_LANES; n<VM_RPORTS; n++) begin //{
        if ((nn_vm_rd_cmd_addr[n][VM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_vm_rd_cmd_valid[n])
        begin    //select read operation
          f                      |= 1'b1;
        end
      end //}

      end
    end //}
// spyglass enable_block W362
  end : vm_ecc_PROC  

  ///////////////////get load data and data valid/////////////////////////////
  //
  always_comb
  begin: vm_bus_rdata_PROC
    nn_vm_rd_rdata = '0;
    for (int n=0; n<VM_RPORTS; n++) // {
    begin
      for (int i=0; i<NUM_VM_BANKS; i++) //{
      begin
        if (bank_r[n][2][i])
        begin
          nn_vm_rd_rdata[n]    |= int_vm_rd_c_rdata[i];   //return corrected data when request available
        end        
      end //}
    end //}
  end : vm_bus_rdata_PROC    
  
  `ifdef E2E_DEC_INFO
    string qual_hier;
    initial qual_hier = $sformatf("%m");
  `endif
  always_comb
  begin: vm_bus_ecc_PROC
    rd_ecc_sel     = '0;
    for (int n=0; n<VM_RPORTS; n++) // {
    begin
      for (int i=0; i<NUM_VM_BANKS; i++) //{
      begin
        if (bank_r[n][2][i])
        begin
          rd_ecc_sel[i]   |= 1'b1;
        end
      end //}
    end //}
  end : vm_bus_ecc_PROC

if (CFG_NPU_MEM_ECC)
begin : vm_mem_ecc_blk

  //
  // VM ecc instance
  //
  logic       [NUM_VM_BANKS-1:0][ISIZE*PIX_W-1:0] wr_tmp_dec;
  logic       [NUM_VM_BANKS-1:0][ISIZE*PIX_W-1:0] rd_tmp_dec;
  logic       [NUM_VM_BANKS-1:0] [VM_NUM_ECC-1:0] gen_sb_err_ql;         // sbe generated by latent ecc decoder
  logic       [NUM_VM_BANKS-1:0] [VM_NUM_ECC-1:0] gen_db_err_ql;         // dbe generated by latent ecc decoder


  for (genvar gvr_i = 0; gvr_i < NUM_VM_BANKS; gvr_i++)
  begin : ecc_per_bank_PRC
    assign wr_tmp_dec[gvr_i] = nn_vm_rd_rdata_r[gvr_i];
    assign int_vm_rd_c_rdata[gvr_i] = rd_tmp_dec[gvr_i];
// spyglass disable_block W287b
//SMD:Unconnect output
//SJ :Intentionally unconnected
    for(genvar gvr_j = 0; gvr_j < VM_NUM_ECC; gvr_j++)
      begin: vm_ecc_dec_inst   
        vm_ecc_2nd_decoder 
        u_main_vm_ecc_dec (
          .enable           (mem_ecc_en),
          .data_in          (wr_tmp_dec[gvr_i][VM_ECC_UNIT_DW*gvr_j+:VM_ECC_UNIT_DW]),
          .syndrome         (),
          .ecc_in           (nn_vm_rd_ecc_r[gvr_i][gvr_j]),
          .ecc_out          (),
          .data_out         (rd_tmp_dec[gvr_i][VM_ECC_UNIT_DW*gvr_j+:VM_ECC_UNIT_DW]),
          .single_err       (gen_sb_err[gvr_i][gvr_j]),
          .double_err       (gen_db_err[gvr_i][gvr_j])
        );
  `ifdef MEM_ECC_INFO
    initial $display("MEM_E2E_DEC_INFO Dec: %m.u_vm_ecc_dec");
  `endif
        assign gen_sb_err_ql[gvr_i][gvr_j] = (rd_ecc_sel[gvr_i])? gen_sb_err[gvr_i][gvr_j] : 1'b0;
        assign gen_db_err_ql[gvr_i][gvr_j] = (rd_ecc_sel[gvr_i])? gen_db_err[gvr_i][gvr_j] : 1'b0;
      end: vm_ecc_dec_inst
// spyglass enable_block W287b

    logic [ISIZE*PIX_W-1:0] wr_tmp_enc;   
    assign wr_tmp_enc = nn_vm_wr_wdata_nxt[gvr_i];
    for(genvar gvr_j = 0; gvr_j < VM_NUM_ECC; gvr_j++)
      begin: vm_ecc_enc_inst
        vm_ecc_2nd_encoder
        u_vm_ecc_2nd_encoder (
          .data_in (wr_tmp_enc[gvr_j*VM_ECC_UNIT_DW+:VM_ECC_UNIT_DW]),
          .ecc     (nn_vm_wr_ecc_nxt[gvr_i][gvr_j])
        );
      end: vm_ecc_enc_inst
  end : ecc_per_bank_PRC
  assign sb_err_aggr   = |gen_sb_err_ql;
  assign db_err_aggr   = |gen_db_err_ql;
end // vm_mem_ecc_blk

  // Output Assign
  assign vm_addr    = vm_addr_r;
  assign vm_wdata   = nn_vm_wr_wdata_r;
  assign vm_mem_en  = vm_mem_en_r;
  assign vm_ls      = vm_ls_r;
  assign vm_ldst_en = vm_ldst_en_r;
  assign vm_wstrb   = nn_vm_wr_wstrb_r;
  // no support for deep-sleep
  assign vm_ds      = '0;
  assign vm_wecc    = nn_vm_wr_ecc_r;
  assign vm_ecc_wstrb = nn_vm_wr_ecc_wstrb_r;

endmodule : vm_mux_logic_data_addr
