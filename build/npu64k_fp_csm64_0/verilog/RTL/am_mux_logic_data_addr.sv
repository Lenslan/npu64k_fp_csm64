/*
 * Copyright (C) 2021-2023 Synopsys, Inc. All rights reserved.
 *
 * SYNOPSYS CONFIDENTIAL - This is an unpublished, confidential, and
 * proprietary work of Synopsys, Inc., and may be subject to patent,
 * copyright, trade secret, and other legal or contractual protection.
 * This work may be used only pursuant to the terms and conditions of a
 * written license agreement with Synopsys, Inc. All other use, reproduction,
 * distribution, or disclosure of this work is strictly prohibited.
 *
 * The entire notice above must be reproduced on all authorized copies.
 */

//
// Top-level demo file for the AM BUS 
//
 
`include "npu_defines.v"
`include "npu_am_macros.svh"
`include "npu_am_ecc_macros.sv"

`ifndef NPU_ECC_TYPES_IMPORTED
`define NPU_ECC_TYPES_IMPORTED
import npu_ecc_types::*;
`endif
// spyglass disable_block W240
// SMD: Declared but not read
// SJ: Reviewed
module am_mux_logic_data_addr
  import npu_types::*;
#(
    parameter AM_RPORTS=5+1,
    parameter AM_WPORTS=4+1,
    parameter NUM_AM_BANKS=2
   )
  (
   //
   // interfaces
   //
   // write request
   input  logic     [AM_WPORTS-1:0]     nn_am_wr_cmd_valid,  // write command valid
   input  am_addr_t [AM_WPORTS-1:0]     nn_am_wr_cmd_addr,   // write command address
   input  vyixacc_t [AM_WPORTS-1:0]     nn_am_wr_wdata,      // write data
   // read request
   input  logic     [AM_RPORTS-1:0]     nn_am_rd_cmd_valid,  // read command valid
   input  am_addr_t [AM_RPORTS-1:0]     nn_am_rd_cmd_addr,   // read command address
   output vyixacc_t [AM_RPORTS-1:0]     nn_am_rd_rdata,      // read data   
   // muxed request
   output am_addr_t [NUM_AM_BANKS-1:0]  am_addr,    // command address
   output vyixacc_t [NUM_AM_BANKS-1:0]  am_wdata,   // write data
   input  vyixacc_t [NUM_AM_BANKS-1:0]  am_rdata,   // read data

   input  logic     [NUM_AM_BANKS-1:0]  am_mem_en_r,
   input  logic     [NUM_AM_BANKS-1:0]  am_ls_r,
   input  logic     [NUM_AM_BANKS-1:0]  am_ldst_en_r,
   input  ixambit_t [NUM_AM_BANKS-1:0]  nn_am_wr_wstrb_r,

   output logic     [NUM_AM_BANKS-1:0]  am_mem_en,  // load enable
   output logic     [NUM_AM_BANKS-1:0]  am_ls,      // light sleep
   output logic     [NUM_AM_BANKS-1:0]  am_ds,      // deep sleep
   output logic     [NUM_AM_BANKS-1:0]  am_ldst_en, // store enable
   output ixambit_t [NUM_AM_BANKS-1:0]  am_wstrb,   // write strobe

   //
   // am ecc
   //
   input  logic          am_prot_en,
   // am mem access interface
   output am_ecc_c_t  [NUM_AM_BANKS-1:0]                     am_wecc,  // write ecc
   output             [NUM_AM_BANKS-1:0] [AM_NUM_ECC-1:0]    am_ecc_wstrb,

   // am port access interface

// input signals
   input  am_addr_t   [NUM_AM_BANKS-1:0]                     am_addr_r,
   input  vyixacc_t   [NUM_AM_BANKS-1:0]                     nn_am_wr_wdata_r,
   input  vyixacc_t   [NUM_AM_BANKS-1:0]                     nn_am_rd_rdata_r,
   input  am_ecc_c_t  [NUM_AM_BANKS-1:0]                     nn_am_wr_ecc_r,
   input  logic       [NUM_AM_BANKS-1:0] [AM_NUM_ECC-1:0]    nn_am_wr_ecc_wstrb_r,
   input  am_ecc_c_t  [NUM_AM_BANKS-1:0]                     nn_am_rd_ecc_r,
   input  logic       [AM_RPORTS-1:0][2:0][NUM_AM_BANKS-1:0] bank_r,

// output signals  
   output am_addr_t   [NUM_AM_BANKS-1:0]                     am_addr_nxt,        
   output vyixacc_t   [NUM_AM_BANKS-1:0]                     nn_am_wr_wdata_nxt, 

  // mem ecc
   output am_ecc_c_t  [NUM_AM_BANKS-1:0]                     nn_am_wr_ecc_nxt,   // ecc generated by ecc encoder
   output logic                                              sb_err_aggr,
   output logic                                              db_err_aggr,
   // am initialization
   input logic      am_init,
   input am_addr_t  am_init_wr_cmd_addr, // am init write command address
   //
   // clock and rst_a
   //
   input logic      clk,                   // clock, all logic clocked at posedge
   input logic      rst_a                  // asynchronous rst_a, active high


  );
// spyglass enable_block W240

  localparam AM_PORTS_WIDTH=$clog2(NUM_AM_BANKS);

  // mem ecc
  logic mem_ecc_en;
  assign mem_ecc_en = am_prot_en;
  logic       [NUM_AM_BANKS-1:0] [AM_NUM_ECC-1:0] gen_sb_err;         // sbe generated by ecc decoder
  logic       [NUM_AM_BANKS-1:0] [AM_NUM_ECC-1:0] gen_db_err;         // dbe generated by ecc decoder
  vyixacc_t   [NUM_AM_BANKS-1:0]                  int_am_rd_c_rdata;
  logic       [NUM_AM_BANKS-1:0]                  rd_ecc_sel;
  
  logic f;

  always_comb
  begin : am_bus_ack_PROC

    am_addr_nxt         = '0;
    nn_am_wr_wdata_nxt  = '0;

// spyglass disable_block W362 W116
//SMD:Width mismatch
//SJ :Ignore $unsigned(i) int index operation in loop
    for (int i=0; i<NUM_AM_BANKS; i++) begin //{
      if (am_init) begin //{
        am_addr_nxt[i]                    |= am_init_wr_cmd_addr[9:AM_PORTS_WIDTH];
        nn_am_wr_wdata_nxt[i]             |= '0;
      end //}
      else begin //{
      f = 1'b0;
      // conv read has highest priority
      if ((nn_am_rd_cmd_addr[0][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_rd_cmd_valid[0]) 
      begin    //select read operation
        am_addr_nxt[i]                    |= f ? '0 : nn_am_rd_cmd_addr[0][9:AM_PORTS_WIDTH];
        f                                 |= 1'b1;
      end
      // conv write has second highest priority
      if ((nn_am_wr_cmd_addr[0][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_wr_cmd_valid[0]) 
      begin // select write operation
        am_addr_nxt[i]                    |= f ? '0 : nn_am_wr_cmd_addr[0][9:AM_PORTS_WIDTH];
        nn_am_wr_wdata_nxt[i]             |= f ? '0 : nn_am_wr_wdata[0];
        f                                 |= 1'b1;
      end
      // gtoa read has third highest priority
      if ((nn_am_rd_cmd_addr[1][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_rd_cmd_valid[1]) 
      begin    //select read operation
        am_addr_nxt[i]                    |= f ? '0 : nn_am_rd_cmd_addr[1][9:AM_PORTS_WIDTH];
        f                                 |= 1'b1;
      end
      // gtoa write has fourth highest priority
      if ((nn_am_wr_cmd_addr[1][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_wr_cmd_valid[1]) 
      begin // select write operation
        am_addr_nxt[i]                    |= f ? '0 : nn_am_wr_cmd_addr[1][9:AM_PORTS_WIDTH];
        nn_am_wr_wdata_nxt[i]             |= f ? '0 : nn_am_wr_wdata[1];
        f                                 |= 1'b1;
      end
      
      // rest
      for (int n=2; n<AM_RPORTS; n++) begin //{
        if ((nn_am_rd_cmd_addr[n][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_rd_cmd_valid[n]) 
        begin    //select read operation
          am_addr_nxt[i]                  |= f ? '0 : nn_am_rd_cmd_addr[n][9:AM_PORTS_WIDTH];
          f                               |= 1'b1;
        end
      end //}

      for (int m=2; m<AM_WPORTS; m++) begin //{
        if ((nn_am_wr_cmd_addr[m][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_wr_cmd_valid[m]) 
        begin // select write operation
          am_addr_nxt[i]                  |= f ? '0 : nn_am_wr_cmd_addr[m][9:AM_PORTS_WIDTH];
          nn_am_wr_wdata_nxt[i]           |= f ? '0 : nn_am_wr_wdata[m];
          f                               |= 1'b1;
        end
      end //}
      end

    end //}
// spyglass enable_block W362 W116
  end : am_bus_ack_PROC

   `include "am_ecc_2nd_func.sv"
  always_comb
  begin : am_ecc_PROC
    logic f;

// spyglass disable_block W362
//SMD:Width mismatch
//SJ :Ignore $unsigned(i) int index operation in loop
    for (int i=0; i<NUM_AM_BANKS; i++) begin //{
      if (am_init) begin //{
      end //}
      else begin //{
      f = 1'b0;
      // conv read has highest priority
      if ((nn_am_rd_cmd_addr[0][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_rd_cmd_valid[0]) 
      begin    //select read operation
        f                                 |= 1'b1;
      end
      // conv write has second highest priority
      if ((nn_am_wr_cmd_addr[0][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_wr_cmd_valid[0]) 
      begin // select write operation
        f                                 |= 1'b1;
      end
      // gtoa read has third highest priority
      if ((nn_am_rd_cmd_addr[1][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_rd_cmd_valid[1]) 
      begin    //select read operation
        f                                 |= 1'b1;
      end
      // gtoa write has fourth highest priority
      if ((nn_am_wr_cmd_addr[1][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_wr_cmd_valid[1]) 
      begin // select write operation
        f                                 |= 1'b1;
      end
      
      // rest
      for (int n=2; n<AM_RPORTS; n++) begin //{
        if ((nn_am_rd_cmd_addr[n][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_rd_cmd_valid[n]) 
        begin    //select read operation
          f                               |= 1'b1;
        end
      end //}

      for (int m=2; m<AM_WPORTS; m++) begin //{
        if ((nn_am_wr_cmd_addr[m][AM_PORTS_WIDTH-1:0] == unsigned'(i)) && nn_am_wr_cmd_valid[m]) 
        begin // select write operation
          f                               |= 1'b1;
        end
      end //}
      end
    end //}
// spyglass enable_block W362
  end : am_ecc_PROC 

  ///////////////////get load data and data valid/////////////////////////////
  //
  always_comb
  begin : am_bus_rdata_PROC
    nn_am_rd_rdata = '0;
    for (int n=0; n<AM_RPORTS; n++) // {
    begin
      for (int i=0; i<NUM_AM_BANKS; i++) //{
      begin
        if (bank_r[n][2][i])
        begin
          nn_am_rd_rdata[n]  |= int_am_rd_c_rdata[i];    //return corrected data when request avaliable
        end        
      end //}
    end //}
  end : am_bus_rdata_PROC

  `ifdef E2E_DEC_INFO
    string qual_hier;
    initial qual_hier = $sformatf("%m");
  `endif
localparam CFG_NPU_MEM_ECC = 1;
  always_comb
  begin : am_bus_ecc_PROC
    rd_ecc_sel     = '0;
    for (int n=0; n<AM_RPORTS; n++) // {
    begin
      for (int i=0; i<NUM_AM_BANKS; i++) //{
      begin
        if (bank_r[n][2][i])
        begin
          rd_ecc_sel[i]   |= 1'b1;
        end
      end //}
    end //}
  end : am_bus_ecc_PROC

if (CFG_NPU_MEM_ECC)
begin : am_mem_ecc_blk
  //
  // AM ecc instance
  //    
  logic       [NUM_AM_BANKS-1:0][VSIZE*ISIZE*ACC_W-1:0] wr_tmp_dec;
  logic       [NUM_AM_BANKS-1:0][VSIZE*ISIZE*ACC_W-1:0] rd_tmp_dec;
  logic       [NUM_AM_BANKS-1:0] [AM_NUM_ECC-1:0] gen_sb_err_ql;
  logic       [NUM_AM_BANKS-1:0] [AM_NUM_ECC-1:0] gen_db_err_ql;


  for (genvar gvr_i = 0; gvr_i < NUM_AM_BANKS; gvr_i++)
  begin : ecc_per_bank_PROC    
    assign wr_tmp_dec[gvr_i] = nn_am_rd_rdata_r[gvr_i];
    assign int_am_rd_c_rdata[gvr_i] = rd_tmp_dec[gvr_i];
// spyglass disable_block W287b
//SMD:Unconnect output
//SJ :Intentionally unconnected
    for(genvar gvr_j = 0; gvr_j < AM_NUM_ECC; gvr_j++)
      begin: am_ecc_dec_inst
        am_ecc_2nd_decoder 
        u_main_am_ecc_dec (
          .enable           (mem_ecc_en),
          .data_in          (wr_tmp_dec[gvr_i][AM_ECC_UNIT_DW*gvr_j+:AM_ECC_UNIT_DW]),
          .syndrome         (),
          .ecc_in           (nn_am_rd_ecc_r[gvr_i][gvr_j]),
          .ecc_out          (),
          .data_out         (rd_tmp_dec[gvr_i][AM_ECC_UNIT_DW*gvr_j+:AM_ECC_UNIT_DW]),        
          .single_err       (gen_sb_err[gvr_i][gvr_j]),
          .double_err       (gen_db_err[gvr_i][gvr_j]) 
        );
  `ifdef MEM_ECC_INFO
    initial $display("MEM_E2E_DEC_INFO Dec: %m.u_main_am_ecc_dec");
  `endif
        assign gen_sb_err_ql[gvr_i][gvr_j] = (rd_ecc_sel[gvr_i])? gen_sb_err[gvr_i][gvr_j] : 1'b0;
        assign gen_db_err_ql[gvr_i][gvr_j] = (rd_ecc_sel[gvr_i])? gen_db_err[gvr_i][gvr_j] : 1'b0;
      end: am_ecc_dec_inst
// spyglass enable_block W287b

    logic [VSIZE*ISIZE*ACC_W-1:0] wr_tmp_enc;
    assign wr_tmp_enc = nn_am_wr_wdata_nxt[gvr_i];
    for(genvar gvr_j = 0; gvr_j < AM_NUM_ECC; gvr_j++)
      begin: am_ecc_enc_inst
        am_ecc_2nd_encoder
        u_am_ecc_2nd_encoder (
          .data_in (wr_tmp_enc[gvr_j*AM_ECC_UNIT_DW+:AM_ECC_UNIT_DW]),
          .ecc     (nn_am_wr_ecc_nxt[gvr_i][gvr_j])
        );
      end: am_ecc_enc_inst
  end : ecc_per_bank_PROC

  assign sb_err_aggr   = |gen_sb_err_ql;
  assign db_err_aggr   = |gen_db_err_ql;
end // am_mem_ecc_blk

  // Output Assign
  // SRAM Interface
  assign am_addr    = am_addr_r;
  assign am_wdata   = nn_am_wr_wdata_r;
  assign am_mem_en  = am_mem_en_r;
  assign am_ls      = am_ls_r;
  assign am_ldst_en = am_ldst_en_r;
  assign am_wstrb   = nn_am_wr_wstrb_r;
  // no support for deep-sleep
  assign am_ds      = '0;
  assign am_wecc    = nn_am_wr_ecc_r;
  assign am_ecc_wstrb = nn_am_wr_ecc_wstrb_r;

endmodule : am_mux_logic_data_addr
