
#Source the user input file
source -echo -verbose ./setup/inputs.tcl
puts "Info: Running script [info script]\n"

###############################################################################
# Project paths

# Bring environment variables into TCL land
set NPU_HOME_RLS $::env(NPU_HOME_RLS)
set NPU_DEPS_RLS $::env(NPU_DEPS_RLS)
set NPU_HOME     $NPU_HOME_RLS
set NPU_DEPS     $NPU_DEPS_RLS
puts "Info: NPU_HOME_RLS = $NPU_HOME_RLS"
puts "Info: NPU_DEPS_RLS = $NPU_DEPS_RLS"


# Absolute path to ARChitect project build dir of the L1 HS with RDF configured and executed
# The NDM tech libs will be taken here
# Take from the makefile
set ARC_RDF_PRJ     $::env(ARC_RDF_PRJ)
set CLN_RDF_PRJ     $::env(CLN_RDF_PRJ)
set CLN_RDF_LIB_PRJ $::env(CLN_RDF_LIB_PRJ)
if { [info exists ::env(VPX_RDF_PRJ)] } {
    set VPX_RDF_PRJ $::env(VPX_RDF_PRJ)
} else {
    set VPX_RDF_PRJ ""
}

# Use in mcmm.tcl
set ARC_PRJ_DIR ${ARC_RDF_PRJ}/build

# Memories not generated by SEIF in the ARC project
set EXTRA_MEM_DIR   $::env(AM_VM_RAM_MACROS)


###############################################################################
# Read a manifest file which contains environment variables and substitute them
# such as ${NPU_HOME}
source ${NPU_HOME_RLS}/bin/read_npu_manifest.tcl
#source ${NPU_HOME}/tools/package/read_npu_manifest.tcl

###############################################################################
# Add all source files in RTL_SOURCE_FILES
set SYN_MANIFEST $::env(SYN_MANIFEST)
puts "Info: SYN_MANIFEST = ${SYN_MANIFEST}"

set rtlsrc ""
#lappend rtlsrc {*}[glob -nocomplain -directory ${EXTRA_MEM_DIR}/rtl *v]
lappend rtlsrc {*}[read_npu_manif ${SYN_MANIFEST}]

set RTL_SOURCE_FILES [join $rtlsrc]
# Sanity check
foreach f $RTL_SOURCE_FILES {
    puts "RTL_SRC: $f"
    if {![file exists $f]} { puts "Error: file not found $f" }
}

write_npu_manifest "${DESIGN_NAME}_generated_manifest" $RTL_SOURCE_FILES

###############################################################################
# Libs and constraints

#Set the target: 28,16,12,07,05,04,03
if { [info exists ::env(RTLA_TECH)] } {
    set TECHNOLOGY $::env(RTLA_TECH)
} else {
    set TECHNOLOGY "07"
}

set UPF_FILE                    ${ARC_RDF_PRJ}/build/constraints/${DESIGN_NAME}.upf

if { [info exists ::env(SYN_SDC)] } {
  set CONSTRAINTS_INPUT_FILE $::env(SYN_SDC)
} else {
  set CONSTRAINTS_INPUT_FILE      ${NPU_HOME_RLS}/syn/constraints/${DESIGN_NAME}.sdc
}

set TCL_PARASITIC_SETUP_FILE    ${ARC_RDF_PRJ}/build/scripts/fc/rm_fc_scripts/init_design.read_parasitic_tech.tcl

#For 16nm implementation
#If mapped SDC is used we could directly call the build/scripts/icc2_rm/rm_icc2_flat_scripts/mcmm.tcl

set TCL_MCMM_SETUP_FILE         "./scripts/mcmm.tcl"
#set TCL_MCMM_SETUP_FILE         "DONT_USE_MCMM_FOR_NOW"

set TECH_LIB			""

set REFERENCE_LIBRARY		[glob -tails -nocomplain -directory ${ARC_RDF_PRJ}/build/ndm *.ndm]
append REFERENCE_LIBRARY  " "   [glob -tails -nocomplain -directory ${EXTRA_MEM_DIR}/ndm *.ndm]
append REFERENCE_LIBRARY  " "   [glob -tails -nocomplain -directory ${CLN_RDF_LIB_PRJ}/build/ndm mem*.ndm] ; # only mem libs
if { [file exists $VPX_RDF_PRJ] } {
    set vpxmemlib               [glob -tails -nocomplain -directory ${VPX_RDF_PRJ}/build/ndm mem*.ndm] ; # only mem libs
    foreach mlib $vpxmemlib {
        # Avoid duplicates with L1/L2 ARC HS
        if {[lsearch -exact $REFERENCE_LIBRARY $mlib] < 0} { append REFERENCE_LIBRARY  " " $mlib }
    }
}
foreach f $REFERENCE_LIBRARY { puts "==> RefLib: $f" }

set  TECH_FILE [ exec grep "^set TECH_FILE" ${ARC_RDF_PRJ}/build/scripts/pt/rm_setup/common_setup.tcl | awk {{print $3}} | sed -e "s|\"||g" ]
puts "TECH_FILE => ${TECH_FILE}"

#- general DONT_USE_LIST
if { ${TECHNOLOGY}=="07" } {
    set DONT_USE_LIST [list */*_0P* */*_DEL* */*ECO* */*MMCK* */*_CK_* */*_MM_* */*_S_* */*CB* */*FSDN* */*FDN* */*_64 */*_128]
} elseif { ${TECHNOLOGY}=="12" } {
    set DONT_USE_LIST [list */*_0P* */*_DEL* */*ECO* */*MMCK* */*_CK_* */*LP* */*_MM_* */*_S_* */*FSDN* */*FDN*]
} elseif { ${TECHNOLOGY}=="03" } {
    set DONT_USE_LIST [regsub -all {([0-9a-zA-Z_*]+)} " HDMDBSVT03_BUF_S_* HDMDBSVT03_INV_S_* HDMDBSVT03_FDN* HDMDBSVT03_FSDN*  HDMDBSVT03_DEL* HDMDBSVT03_*_MM_* HDMDBLVTLL03_BUF_S_* HDMDBLVTLL03_INV_S_* HDMDBLVTLL03_FDN* HDMDBLVTLL03_FSDN*  HDMDBLVTLL03_DEL* HDMDBLVTLL03_*_MM_* HDMSBSVT03_BUF_S_* HDMSBSVT03_INV_S_* HDMSBSVT03_FDN* HDMSBSVT03_FSDN*  HDMSBSVT03_DEL* HDMSBSVT03_*_MM_* HDMHBSVT03_BUF_S_* HDMSBSVT03_INV_S_* HDMHBSVT03_FDN* HDMHBSVT03_FSDN* HDMHBSVT03_DEL* HDMHBSVT03_TIE* HDMHBSVT03_*_MM_*  HDMSBLVTLL03_BUF_S_* HDMSBLVTLL03_INV_S_* HDMSBLVTLL03_FDN* HDMSBLVTLL03_FSDN* HDMSBLVTLL03_DEL* HDMSBLVTLL03_*_MM_*  HDMDB*T*_CK_* *0P*  *_48 *_64 *_66" "*/\\1"]
} else {
    set  DONT_USE_LIST  [exec grep  "set dont_use_list" ${ARC_RDF_PRJ}/build/scripts/fc/rm_fc_scripts/fc_dont_use.tcl | grep -v \# | awk {{$1=$2=""; print $0}} | sed -e "s|\"||g" ]
}
#- add customized dont_use_list.tcl based on ${TECHNOLOGY}
set lc_DESIGN_NAME $::env(TOP_MODULE)
if { [file exists ${NPU_HOME_RLS}/syn/rtla_${lc_DESIGN_NAME}/setup/dont_use_list.tcl] } {
  source -echo ${NPU_HOME_RLS}/syn/rtla_${lc_DESIGN_NAME}/setup/dont_use_list.tcl
}
puts "DONT_USE_LIST  => ${DONT_USE_LIST}"

# Settings for power analysis
set PWR_SHELL  "/u/nwtnmgr/image/S-2021.06-PROD-SP1-SP2/latest/Testing/bin/pt_shell"

###############################################################################
# Paths to search for RTL and libraries
#set arc_prj_paths [list \
#    ${ARC_RDF_PRJ}/build/verilog/RTL ${ARC_RDF_PRJ}/build/verilog \
#    ${ARC_RDF_PRJ}/build/ndm \
#    ${ARC_RDF_PRJ}/build/scripts \
#    ${ARC_RDF_PRJ}/build/constraints \
#    ]

set npu_prj_paths [list           \
      ${NPU_HOME_RLS}/verilog     \
      ${NPU_HOME_RLS}/verilog/RTL \
    ]

# This is the customized manifest and serach_paths, ignore all pre-dfined search paths
if { [file exists ${SYN_MANIFEST}.search_paths] } {
  set spth [exec cat ${SYN_MANIFEST}.search_paths]
  puts $spth
  set npu_prj_paths [list ]
  lappend npu_prj_paths {*}${spth}
}

# search_path has preset values from the tool. Only append to it.
lappend search_path {*}${npu_prj_paths} ${ARC_RDF_PRJ}/build/ndm ${EXTRA_MEM_DIR}/ndm ${CLN_RDF_LIB_PRJ}/build/ndm
if { [file exists $VPX_RDF_PRJ] } {
  lappend search_path ${VPX_RDF_PRJ}/build/ndm
}

# Sanity check
foreach d $search_path {
    puts "Info: search_path $d"
    if {![file exists $d]} { puts "Error: not found $d" }
}


###############################################################################
# Outputs

set WORK_DIR                    ./work
if { [info exists ::env(WORK_DIR)] } {
    set WORK_DIR                $::env(WORK_DIR)
}

set DESIGN_LIBRARY	        ${WORK_DIR}/${DESIGN_NAME}.dlib

set REPORTS_DIR                 ./reports
if { [info exists ::env(REPORTS_DIR)] } {
    set REPORTS_DIR             $::env(REPORTS_DIR)
}

set rptpfx                      "${REPORTS_DIR}/${DESIGN_NAME}"

if !{[file exists $WORK_DIR]} {file mkdir $WORK_DIR}
if !{[file exists $REPORTS_DIR]} {file mkdir $REPORTS_DIR}

###############################################################################
# Parallel execution
#

# Local machine / global options (no name)
set_host_options -max_cores ${max_cores}

# Named local host, replace the default command (rsh)
set_host_options -name lhost -max_cores ${max_cores} -submit_command sh
set_host_options -name khost -max_cores ${max_cores} -submit_command sh

# Submit to the compute farm using a custome script
set_host_options -name farm -max_cores ${max_cores} -num_processes 12 -submit_command submitcmdmt.sh
#set_host_options -name block_script -submit_command [list qsub -P bnormal -l mem_free=30G,qsc=m -cwd]

###############################################################################
#Check for variable dependencies in inputs.tcl

if {${IMPLEMENTATION}=="hier" && ${BLOCK_INSTANCES}==""} {
    puts "ERROR: Hierarchical implementation is not possible for block-level. Please add the BLOCK_INSTANCES for top-level hierarchical implementation"
    exit 1
}

if {${IMPLEMENTATION}=="flat" && ${BLOCK_INSTANCES}!=""} {
    puts "ERROR: BLOCK_INSTANCES variable should be empty for flat implementation, it is applicable only for Hier implementation"
    exit 1
}

###############################################################################
# Summary of setup

# Last arg is the string, all the previous args are channels to print to
# default channel if none specified is stdout
proc tee_puts {args} {
    if { [llength $args] == 0 } {
        error "Missing arg in tee_puts"
    } elseif { [llength $args] == 1 } {
        set channels stdout
    } else {
        set channels [lrange $args 0 end-1]
    }
    set str [lindex $args end]
    foreach ch $channels {
        puts $ch $str
    }
}

set rptsetup [open "${REPORTS_DIR}/rtla_setup.txt" w+]

tee_puts $rptsetup "Info: NPU_HOME         = $NPU_HOME"
tee_puts $rptsetup "Info: NPU_DEPS         = $NPU_DEPS"
tee_puts $rptsetup "Info: ARC_RDF_PRJ      = $ARC_RDF_PRJ"
tee_puts $rptsetup "Info: CLN_RDF_PRJ      = $CLN_RDF_PRJ"
tee_puts $rptsetup "Info: CLN_RDF_LIB_PRJ  = $CLN_RDF_LIB_PRJ"
tee_puts $rptsetup "Info: VPX_RDF_PRJ      = $VPX_RDF_PRJ"
tee_puts $rptsetup "Info: EXTRA_MEM_DIR    = $EXTRA_MEM_DIR"
tee_puts $rptsetup "Info: NPU_FMAX         = $NPU_FMAX"
tee_puts $rptsetup "Info: RTLA_UNGROUP     = $RTLA_UNGROUP"
tee_puts $rptsetup "Info: RTLA_CTS         = $RTLA_CTS"
tee_puts $rptsetup "Info: RTLA_LVT_RATIO   = $RTLA_LVT_RATIO"
tee_puts $rptsetup "Info: RTLA_PDM_UPF     = $RTLA_PDM_UPF"
tee_puts $rptsetup "Info: ELAB_ONLY        = $ELAB_ONLY"
tee_puts $rptsetup "Info: SDC_ONLY         = $SDC_ONLY"
tee_puts $rptsetup "Info: SVT_ONLY         = $SVT_ONLY"

close $rptsetup

